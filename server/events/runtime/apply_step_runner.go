package runtime

import (
	"bytes"
	"fmt"
	"github.com/pkg/errors"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/go-version"
	"github.com/runatlantis/atlantis/server/events/models"
)

// ApplyStepRunner runs `terraform apply`.
type ApplyStepRunner struct {
	TerraformExecutor   TerraformExec
	CommitStatusUpdater StatusUpdater
	AsyncTFExec         AsyncTFExec
}

func (a *ApplyStepRunner) Run(ctx models.ProjectCommandContext, extraArgs []string, path string) (string, error) {
	if a.hasTargetFlag(ctx, extraArgs) {
		return "", errors.New("cannot run apply with -target because we are applying an already generated plan. Instead, run -target with atlantis plan")
	}

	planPath := filepath.Join(path, GetPlanFilename(ctx.Workspace, ctx.ProjectConfig))
	contents, err := ioutil.ReadFile(planPath)
	if os.IsNotExist(err) {
		return "", fmt.Errorf("no plan found at path %q and workspace %qâ€“did you run plan?", ctx.RepoRelDir, ctx.Workspace)
	}
	if err != nil {
		return "", errors.Wrap(err, "unable to read planfile")
	}

	var tfVersion *version.Version
	if ctx.ProjectConfig != nil && ctx.ProjectConfig.TerraformVersion != nil {
		tfVersion = ctx.ProjectConfig.TerraformVersion
	}

	var out string
	if a.isRemotePlan(contents) {
		// todo: diff output during apply with output in planfile.
		args := append(append(append([]string{"apply", "-input=false", "-no-color", "-auto-approve"}, extraArgs...), ctx.CommentArgs...))
		out, err = runRemoteOp(ctx, models.ApplyCommand, args, path, tfVersion, a.AsyncTFExec, a.CommitStatusUpdater)
		if err == nil {
			out = a.cleanRemoteOpOutput(out)
		}
	} else {
		// NOTE: we need to quote the plan path because Bitbucket Server can
		// have spaces in its repo owner names which is part of the path.
		args := append(append(append([]string{"apply", "-input=false", "-no-color"}, extraArgs...), ctx.CommentArgs...), fmt.Sprintf("%q", planPath))
		out, err = a.TerraformExecutor.RunCommandWithVersion(ctx.Log, path, args, tfVersion, ctx.Workspace)
	}

	// If the apply was successful, delete the plan.
	if err == nil {
		ctx.Log.Info("apply successful, deleting planfile")
		if removeErr := os.Remove(planPath); removeErr != nil {
			ctx.Log.Warn("failed to delete planfile after successful apply: %s", removeErr)
		}
	}
	return out, err
}

// isRemotePlan returns true if planContents are from a plan that was generated
// using TFE remote operations.
func (a *ApplyStepRunner) isRemotePlan(planContents []byte) bool {
	// We add a header to plans generated by the remote backend so we can
	// detect that they're remote in the apply phase.
	remoteOpsHeaderBytes := []byte(remoteOpsHeader)
	return bytes.Equal(planContents[:len(remoteOpsHeaderBytes)], remoteOpsHeaderBytes)
}

func (a *ApplyStepRunner) hasTargetFlag(ctx models.ProjectCommandContext, extraArgs []string) bool {
	isTargetFlag := func(s string) bool {
		if s == "-target" {
			return true
		}
		split := strings.Split(s, "=")
		return split[0] == "-target"
	}

	for _, arg := range ctx.CommentArgs {
		if isTargetFlag(arg) {
			return true
		}
	}
	for _, arg := range extraArgs {
		if isTargetFlag(arg) {
			return true
		}
	}
	return false
}

// cleanRemoteOpOutput removes unneeded output from before the separator.
// This makes the apply output easier to read.
func (a *ApplyStepRunner) cleanRemoteOpOutput(out string) string {
	sep := "------------------------------------------------------------------------\n"
	sepIdx := strings.Index(out, sep)
	if sepIdx > -1 {
		return out[sepIdx+len(sep):]
	}
	return out
}
